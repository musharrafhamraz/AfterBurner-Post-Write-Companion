"""Monitoring tools — Sentry, Prometheus config, and health checks."""

import os
from typing import Optional

import httpx
from loguru import logger


def setup_sentry(repo_path: str, dsn: Optional[str] = None) -> bool:
    """
    Configure Sentry by ensuring the DSN is present in the project's .env file.

    This does NOT modify source code — it only ensures the environment variable
    is available for the application's existing Sentry SDK integration.

    Args:
        repo_path: Absolute path to the repository.
        dsn: Sentry DSN. Falls back to AFTERBURNER_SENTRY_DSN env.

    Returns:
        True if Sentry was configured successfully.
    """
    dsn = dsn or os.environ.get("AFTERBURNER_SENTRY_DSN")
    if not dsn:
        logger.debug("No Sentry DSN provided — skipping")
        return False

    env_file = os.path.join(repo_path, ".env")

    # Check if SENTRY_DSN already exists in .env
    if os.path.exists(env_file):
        with open(env_file, "r") as f:
            content = f.read()
        if "SENTRY_DSN" in content:
            logger.debug("SENTRY_DSN already configured in .env")
            return True

    # Append SENTRY_DSN
    with open(env_file, "a") as f:
        f.write(f"\n# Sentry (added by Afterburner)\nSENTRY_DSN={dsn}\n")

    logger.info("Configured Sentry DSN in {}", env_file)
    return True


def generate_prometheus_config(repo_path: str, port: int = 8000) -> str:
    """
    Generate a basic Prometheus scrape configuration.

    Creates prometheus.yml in the project root if it doesn't exist.

    Args:
        repo_path: Absolute path to the repository.
        port: Application port to scrape.

    Returns:
        Path to the generated config file.
    """
    config_path = os.path.join(repo_path, "prometheus.yml")

    if os.path.exists(config_path):
        logger.debug("prometheus.yml already exists, skipping generation")
        return config_path

    config_content = f"""# Prometheus scrape config (generated by Afterburner)
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'app'
    static_configs:
      - targets: ['localhost:{port}']
    metrics_path: '/metrics'

  - job_name: 'health'
    static_configs:
      - targets: ['localhost:{port}']
    metrics_path: '/health'
    scrape_interval: 30s
"""

    with open(config_path, "w") as f:
        f.write(config_content)

    logger.info("Generated Prometheus config: {}", config_path)
    return config_path


def verify_health(
    url: str,
    timeout: int = 30,
    expected_status: int = 200,
) -> dict:
    """
    Verify a deployment by hitting its health/root endpoint.

    Args:
        url: URL to check (e.g. https://my-app.vercel.app).
        timeout: Maximum seconds to wait for response.
        expected_status: Expected HTTP status code.

    Returns:
        Dict with 'healthy', 'status_code', 'response_time_ms', and 'error' keys.
    """
    import time

    health_paths = ["/health", "/api/health", "/healthz", "/"]

    for path in health_paths:
        check_url = url.rstrip("/") + path
        try:
            start = time.time()
            response = httpx.get(check_url, timeout=timeout, follow_redirects=True)
            elapsed_ms = (time.time() - start) * 1000

            if response.status_code == expected_status:
                logger.info(
                    "Health check passed: {} → {} ({:.0f}ms)",
                    check_url,
                    response.status_code,
                    elapsed_ms,
                )
                return {
                    "healthy": True,
                    "status_code": response.status_code,
                    "response_time_ms": elapsed_ms,
                    "url": check_url,
                    "error": None,
                }

        except httpx.TimeoutException:
            continue
        except httpx.ConnectError:
            continue
        except Exception as e:
            logger.debug("Health check failed for {}: {}", check_url, str(e))
            continue

    logger.warning("All health check paths failed for {}", url)
    return {
        "healthy": False,
        "status_code": None,
        "response_time_ms": None,
        "url": url,
        "error": "All health check endpoints failed",
    }
